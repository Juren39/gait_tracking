<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>标注辅助工具</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Roboto', sans-serif;
      background: #f0f2f5;
    }
    .container {
      max-width: 1300px;
      margin: 40px auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 30px;
    }
    h1 { text-align: center; margin-bottom: 1rem; }

    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 5px;
      padding: 20px;
      text-align: center;
      color: #555;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 1rem;
      background: #fafafa;
      position: relative;
    }
    .drop-zone input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .drop-zone.disabled {
      border-color: #eee;
      background: #f9f9f9;
      color: #aaa;
      cursor: not-allowed;
    }
    .drop-zone.hover {
      border-color: #07c;
      background: #f0faff;
      color: #07c;
    }

    #controls {
      text-align: center;
      margin-bottom: 1rem;
    }
    #playBtn, #saveJsonBtn, #resetBtn {
      font-size: 1rem;
      padding: 8px 16px;
      margin: 0 8px;
      border: none;
      border-radius: 5px;
      background: #07c;
      color: #fff;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    #playBtn:hover, #saveJsonBtn:hover, #resetBtn:hover {
      background: #059;
    }
    #playBtn:disabled, #saveJsonBtn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    #videoContainer {
      position: relative;
      margin: 20px auto;
      width: 960px; 
    }
    #video {
      display: block;
      background: #000;
      border-radius: 5px;
      width: 960px;
    }
    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      border-radius: 5px;
      width: 960px;
    }

    #correctionPanel {
      margin-top: 20px;
      padding: 15px;
      background: #f8f8f8;
      border-radius: 5px;
    }
    #correctionPanel h2 {
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .track-list {
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 5px;
      background: #fff;
      margin-bottom: 10px;
    }
    .track-item {
      display: flex;
      align-items: center;
      padding: 6px 10px;
      border-bottom: 1px solid #eee;
      font-size: 0.9rem;
    }
    .track-item:last-child {
      border-bottom: none;
    }
    .track-item span {
      margin-right: 8px;
    }
    .track-item input {
      width: 80px;
      margin-right: 10px;
      padding: 2px 5px;
    }
    #noDetMsg {
      color: #888;
      font-size: 0.9rem;
      padding: 5px;
    }
    /* 新增“应用更新”按钮的大尺寸样式 */
    #applyFrameUpdatesBtn {
      display: inline-block;
      font-size: 1.2rem;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: #28a745;
      color: #fff;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.2s ease;
    }
    #applyFrameUpdatesBtn:hover {
      background: #218838;
      transform: scale(1.05);
    }
    #applyFrameUpdatesBtn:active {
      background: #1e7e34;
      transform: scale(0.95);
    }
  </style>
</head>
<body>
<div class="container">
  <h1>标注辅助工具</h1>
  <p style="text-align:center;">
    1) 最开始为初始状态：无法播放<br/>
    2) 需要放入 video(.mp4) 和标签文件(txt/json)后可点击“播放”<br/>
    3) 播放后禁止再次点击“播放”<br/>
    4) 点击“重新上传”回到初始状态<br/>
    <br/>
    注：如需自定义保存路径，请在浏览器设置中启用“每次下载都询问保存位置”等类似选项
  </p>

  <!-- 拖拽区域：video（mp4） -->
  <div id="videoDropZone" class="drop-zone">
    <p>拖拽/点击上传视频文件 (mp4)</p>
    <input type="file" id="videoInput" accept=".mp4" />
  </div>

  <!-- 拖拽区域：txt/json -->
  <div id="jsonDropZone" class="drop-zone">
    <p>拖拽/点击上传标签文件 (txt / json)</p>
    <input type="file" id="jsonInput" accept=".txt,.json" />
  </div>

  <!-- 按钮 -->
  <div id="controls">
    <button id="playBtn" disabled>播放</button>
    <button id="saveJsonBtn" disabled>保存JSON</button>
    <button id="resetBtn">重新上传</button>
  </div>

  <!-- 视频 + 画布 -->
  <div id="videoContainer">
    <video id="video" controls></video>
    <canvas id="overlayCanvas"></canvas>
  </div>

  <!-- 修正区 -->
  <div id="correctionPanel">
    <h2>修正区</h2>
    <div id="correctionInfo"></div>
    <div id="currentFrameTracks" class="track-list"></div>
    <!-- 在这里增加一个“应用更新”按钮，一次性更新并重绘 -->
    <button id="applyFrameUpdatesBtn" style="display:none;">应用更新</button>
  </div>
</div>

<script>
  /************************************************************
   * 文件状态管理：initial, playable, playing
   ************************************************************/
  let currentState = "initial"; 
  // initial: 初始状态 => 不可播放
  // playable: 已选video+label => 可点击播放
  // playing: 已点击播放 => 播放中 => 不可再点击播放

  function setState(newState) {
    currentState = newState;
    console.log("Set State =>", newState);
    const playBtn = document.getElementById('playBtn');
    switch(newState) {
      case "initial":
        // 禁用播放、保存按钮
        video.controls = false;
        playBtn.disabled = true;
        document.getElementById('saveJsonBtn').disabled = true;
        break;
      case "playable":
        // 可点击播放
        video.controls = false;
        playBtn.disabled = false;
        break;
      case "playing":
        // 禁用播放按钮
        video.controls = true;
        playBtn.disabled = true;
        // 启用保存按钮
        document.getElementById('saveJsonBtn').disabled = false;
        break;
    }
  }

  /************************************************************
   * 全局变量
   ************************************************************/
  let videoFile = null;       
  let jsonFile = null;        
  let labelData = null;       
  let video = null;
  let canvas = null;
  let ctx = null;
  let fps = 30;               
  let videoWidth = 0;
  let videoHeight = 0;
  let currentFrameIndex = 0;

  let playing = false;        
  let useRAF = false;         

  // 重新上传时恢复UI
  let originalVideoDropHTML = "";
  let originalJsonDropHTML = "";
  
  // 用于保存时设置默认文件名
  let originalJsonBaseName = "labels";

  window.addEventListener('load', () => {
    video = document.getElementById('video');
    canvas = document.getElementById('overlayCanvas');
    ctx = canvas.getContext('2d');

    // 默认状态: initial
    setState("initial");

    const videoDropZone = document.getElementById('videoDropZone');
    const txtDropZone   = document.getElementById('jsonDropZone');

    setupDropZone(
      videoDropZone,
      document.getElementById('videoInput'),
      onVideoFileSelected,
      ['mp4']
    );
    setupDropZone(
      txtDropZone,
      document.getElementById('jsonInput'),
      onTxtFileSelected,
      ['txt','json']
    );

    // 记录原始HTML，便于“重新上传”时复原
    originalVideoDropHTML = videoDropZone.innerHTML;
    originalJsonDropHTML  = txtDropZone.innerHTML;

    // 绑定按钮事件
    document.getElementById('playBtn').addEventListener('click', onPlayButtonClick);
    document.getElementById('saveJsonBtn').addEventListener('click', onSaveJsonClick);
    document.getElementById('resetBtn').addEventListener('click', onResetUpload);

    // 监听视频事件
    video.addEventListener('play', () => {
      playing = true;
      if (useRAF) {
        requestAnimationFrame(rafRender);
      } else {
        video.requestVideoFrameCallback(videoFrameCallback);
      }
    });
    video.addEventListener('pause', () => { playing = false; });
    video.addEventListener('ended', () => { playing = false; });
    video.addEventListener('seeking', () => { playing = false; });
    video.addEventListener('seeked', () => {
      currentFrameIndex = Math.floor(video.currentTime * fps);
      renderCurrentFrame();
      if (!video.paused && !video.ended) {
        playing = true;
        if (useRAF) requestAnimationFrame(rafRender);
        else video.requestVideoFrameCallback(videoFrameCallback);
      }
    });

    // “应用更新”按钮：一次性批量更新
    document.getElementById('applyFrameUpdatesBtn').addEventListener('click', applyFrameUpdates);
  });

  /************************************************************
   * 文件选择逻辑
   ************************************************************/
  function onVideoFileSelected(file) {
    videoFile = file;
    checkReadyToPlay();
  }
  function onTxtFileSelected(file) {
    jsonFile = file;
    checkReadyToPlay();
  }

  // 如果 videoFile 和 jsonFile 都已选，则进入可播放状态
  function checkReadyToPlay() {
    if (videoFile && jsonFile && currentState === "initial") {
      setState("playable");
    }
  }

  /************************************************************
   * 播放按钮: 读取标签文件并解析为JSON, 再加载视频
   ************************************************************/
  function onPlayButtonClick() {
    if (currentState !== "playable") return;

    // 一旦点击播放 => playing状态
    setState("playing");

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        labelData = JSON.parse(e.target.result);
      } catch (err) {
        alert('文件内容解析为JSON失败: ' + err);
        return;
      }
      if (labelData.fps) {
        fps = labelData.fps;
      }
      if (labelData.frames) {
        // 统一把 track_id 转为字符串，避免数字/字符串不匹配
        labelData.frames.forEach(frame => {
          frame.detections.forEach(det => {
            det.track_id = String(det.track_id);
          });
        });
      }

      const fileName = jsonFile.name; 
      const dotIdx = fileName.lastIndexOf('.');
      if (dotIdx > 0) {
        originalJsonBaseName = fileName.slice(0, dotIdx); 
      } else {
        originalJsonBaseName = fileName;
      }
      loadVideoFile(videoFile);
    };
    reader.readAsText(jsonFile); 
  }

  function loadVideoFile(file) {
    video.src = '';
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const url = URL.createObjectURL(file);
    video.src = url;

    video.addEventListener('loadedmetadata', () => {
      videoWidth = video.videoWidth;
      videoHeight = video.videoHeight;
      canvas.width = videoWidth;
      canvas.height = videoHeight;

      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
        useRAF = false;
      } else {
        useRAF = true;
      }
      video.play();
    });
  }

  /************************************************************
   * 手动保存 JSON
   ************************************************************/
  function onSaveJsonClick() {
    if (!labelData) return;
    const defaultFileName = "labels.txt"; 
    downloadJson(labelData, defaultFileName);
  }

  function downloadJson(dataObj, fileName) {
    const jsonStr = JSON.stringify(dataObj, null, 2);
    const blob = new Blob([jsonStr], {type: 'application/json'});
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;  
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /************************************************************
   * VideoFrameCallback / RAF 
   ************************************************************/
  function videoFrameCallback(now, metadata) {
    if (video.paused || video.ended) return;
    currentFrameIndex = Math.floor(metadata.mediaTime * fps);
    renderCurrentFrame();
    video.requestVideoFrameCallback(videoFrameCallback);
  }

  function rafRender() {
    if (!playing) return;
    currentFrameIndex = Math.floor(video.currentTime * fps);
    renderCurrentFrame();
    requestAnimationFrame(rafRender);
  }

  /************************************************************
   * 绘制 & 修正面板逻辑
   ************************************************************/
  function renderCurrentFrame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!labelData || !labelData.frames) {
      updateCorrectionPanel([]);
      return;
    }
    const frameData = labelData.frames.find(f => f.frame_id === currentFrameIndex);
    if (!frameData) {
      updateCorrectionPanel([]);
      return;
    }

    // 画框
    frameData.detections.forEach(det => {
      const [x1, y1, x2, y2] = det.bbox;
      const w = x2 - x1;
      const h = y2 - y1;
      ctx.strokeStyle = "red";
      ctx.lineWidth = 5;
      ctx.strokeRect(x1, y1, w, h);

      ctx.fillStyle = "red";
      ctx.font = "bold 30px sans-serif";
      ctx.fillText(`ID: ${det.track_id}`, x1, y1 - 5);
    });

    // 更新修正面板
    updateCorrectionPanel(frameData.detections);
  }

  function updateCorrectionPanel(detections) {
    const info = document.getElementById('correctionInfo');
    const trackList = document.getElementById('currentFrameTracks');
    const applyBtn = document.getElementById('applyFrameUpdatesBtn');

    trackList.innerHTML = '';

    if (detections.length === 0) {
      info.innerHTML = `<p>当前帧: ${currentFrameIndex}，无目标。</p>`;
      trackList.innerHTML = `<p id="noDetMsg">无检测/跟踪框</p>`;
      applyBtn.style.display = 'none'; // 没有可改动的目标时，隐藏“应用更新”按钮
      return;
    }

    info.innerHTML = `<p>当前帧: ${currentFrameIndex}，共有 ${detections.length} 个目标</p>`;
    detections.forEach((det, index) => {
      const container = document.createElement('div');
      container.className = 'track-item';

      // 用 data-* 属性存储旧ID，方便稍后比较
      container.dataset.oldID = det.track_id;

      // 每个目标的行信息
      const idLabel = document.createElement('span');
      idLabel.innerText = 'ID:';
      container.appendChild(idLabel);

      const idInput = document.createElement('input');
      idInput.type = 'text';
      idInput.value = det.track_id; 
      idInput.dataset.idx = index;   // 也可存储在 container 上
      container.appendChild(idInput);

      const bboxLabel = document.createElement('span');
      bboxLabel.style.marginRight = '8px';
      bboxLabel.innerText = `bbox: [${det.bbox.join(', ')}]`;
      container.appendChild(bboxLabel);

      trackList.appendChild(container);
    });

    // 有目标时，显示“应用更新”按钮
    applyBtn.style.display = 'inline-block';
  }

  /************************************************************
   * 一次性批量更新当前帧的ID，再重绘
   * 若同一帧内有冲突(已存在 newID)，则跳过该帧的修改
   ************************************************************/
  function applyFrameUpdates() {
    const trackList = document.getElementById('currentFrameTracks');
    const items = trackList.querySelectorAll('.track-item');

    // 一次性收集所有更新，然后集中修改
    items.forEach(item => {
      const oldID = item.dataset.oldID;
      const input = item.querySelector('input[type="text"]');
      const newID = input.value.trim();

      // 如果有变化则全局更新(带“同帧撞车”检测)
      if (newID && newID !== oldID) {
        globalUpdateTrackIDWithSkipCollision(oldID, newID);
      }
    });

    // 所有更新处理完后，只调用一次渲染
    renderCurrentFrame();
  }

  /**
   * 当修改一个ID时，如果某帧里已经存在 newID，则跳过对该帧的更新（避免同帧出现重复ID）
   */
  function globalUpdateTrackIDWithSkipCollision(oldID, newID) {
    if (!labelData || !labelData.frames) return;

    labelData.frames.forEach(frame => {
      // 先收集该帧所有ID
      const usedIds = new Set(frame.detections.map(det => det.track_id));
      // 如果已存在 newID，则跳过本帧，不作修改
      if (usedIds.has(newID)) {
        return;
      }

      // 否则可以安全地将 oldID -> newID
      frame.detections.forEach(det => {
        if (String(det.track_id) === oldID) {
          det.track_id = newID;
        }
      });
    });
  }

  /************************************************************
   * 重新上传 -> 回到初始状态
   ************************************************************/
  function onResetUpload() {
    setState("initial");
    videoFile = null;
    jsonFile = null;
    labelData = null;
    fps = 30;
    videoWidth = 0;
    videoHeight = 0;
    currentFrameIndex = 0;
    playing = false;
    originalJsonBaseName = "labels";

    video.pause();
    video.src = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 恢复拖拽区HTML与状态
    const videoDropZone = document.getElementById('videoDropZone');
    const txtDropZone   = document.getElementById('jsonDropZone');
    videoDropZone.innerHTML = originalVideoDropHTML;
    txtDropZone.innerHTML   = originalJsonDropHTML;
    videoDropZone.classList.remove('disabled');
    txtDropZone.classList.remove('disabled');

    setupDropZone(
      videoDropZone,
      document.getElementById('videoInput'),
      onVideoFileSelected,
      ['mp4']
    );
    setupDropZone(
      txtDropZone,
      document.getElementById('jsonInput'),
      onTxtFileSelected,
      ['txt','json']
    );

    document.getElementById('correctionInfo').innerHTML = "";
    document.getElementById('currentFrameTracks').innerHTML = "";
    document.getElementById('applyFrameUpdatesBtn').style.display = 'none';
  }

  /************************************************************
   * 通用的拖拽上传处理
   ************************************************************/
  function setupDropZone(dropZone, fileInput, onFileSelected, allowedExts) {
    let fileSelected = false;

    fileInput.addEventListener('change', () => {
      if (fileInput.files && fileInput.files.length > 0) {
        const file = fileInput.files[0];
        if (!checkFileExtension(file.name, allowedExts)) {
          alert(`文件类型不正确，只能选择: ${allowedExts.join(', ')}`);
          fileInput.value = ""; // 重置
          return;
        }
        fileSelected = true;
        dropZone.classList.add('disabled');
        dropZone.innerHTML = `<p>已选择文件：<strong>${file.name}</strong></p>`;
        onFileSelected(file);
      }
    });

    dropZone.addEventListener('dragenter', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!fileSelected) {
        dropZone.classList.add('hover');
      }
    });
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('hover');
    });
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('hover');
      if (fileSelected) {
        return; 
      }
      if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        const file = e.dataTransfer.files[0];
        if (!checkFileExtension(file.name, allowedExts)) {
          alert(`文件类型不正确，只能选择: ${allowedExts.join(', ')}`);
          return;
        }
        fileSelected = true;
        dropZone.classList.add('disabled');
        dropZone.innerHTML = `<p>已选择文件：<strong>${file.name}</strong></p>`;
        onFileSelected(file);
      }
    });
  }

  function checkFileExtension(filename, allowedExts) {
    const ext = filename.split('.').pop().toLowerCase();
    return allowedExts.includes(ext);
  }
</script>
</body>
</html>